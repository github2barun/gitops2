input {
    ######### Uncomment this pipeline address if we use FileBeat and not Logstash directly.
    # pipeline { address => auditpipeline }
    file {
        start_position => "beginning"
        path => ["/var/seamless/log/dealer-management-system/dealer-management-system-data.dump*","/var/seamless/log/product-management/product-management-datafeed.log*","/var/seamless/log/order-management-system/om-data.dump*","/var/seamless/log/inventory-management-system/ims-data.dump","/var/seamless/log/kyc/data-dump/kyc-data.dump*","/var/seamless/log/group-management/group-management-data.dump*","/var/seamless/log/identity-management/dump/identity-management.dump*","/var/seamless/log/identity-management/audit-dump/identity-management-audit-data.dump*","/var/seamless/log/dealer-management-system/dealer-management-system-audit.dump*","/var/seamless/log/contract-management-system/dump/contract-management-system-audit.dump*","/var/seamless/log/txe/txe-data.dump*","/var/seamless/log/batch-scheduling/batch-scheduling-data.dump*","/var/seamless/log/bi-engine/dump/bi-engine-data.dump*"]
        sincedb_path => "/var/seamless/log/sincedb_audit.log"
     }
}
filter{

    json{
        skip_on_invalid_json => true
        source => "message"
    }
mutate {
      convert => { "rootComponent" => "boolean" }
    }
   if ( [eventName] not in ["addReseller","updateReseller","resellerChangeState","getResellerInfo","changePassword","updateUser","addResellerUsers","changeResellerType","getAllResellerTypes","dealerBalanceStatusChange","UPDATE_PRODUCT","DELETE_PRODUCT","DELETE_CATEGORY","ADD_CATEGORY","UPDATE_CATEGORY","ADD_PRODUCT","ADD_PRODUCT_VARIANT","UPDATE_PRODUCT_VARIANT","DELETE_PRODUCT_VARIANT","ADD_TAX","UPDATE_TAX","DELETE_TAX","Login","ForgetPassword","VerifyToken","logout","ORDER_PRODUCT_QUOTA_RULE_CREATED","ORDER_PRODUCT_QUOTA_RULE_DELETED","ORDER_PRODUCT_QUOTA_RULE_UPDATED","RAISE_ORDER","ORDER_ACTION","ORDER_PAYMENT","UPLOAD_EXTERNAL_INVENTORY","REVERSE_ORDER","ORDER_TIMEOUT","ORDER_DELIVERED","ORDER_FAILURE","ADD_RECEIVED_INVENTORY","BULK_ADD_INVENTORY","BULK_ADD_TDR","DELIVER_INVENTORY","INTRANSIT_INVENTORY","RELEASE_INVENTORY","RESERVE_INVENTORY","TRANSFER_INVENTORY","UPDATE_INVENTORIES","ADD_GROUP","ADD_GROUP_ADMINS","ADD_GROUP_MEMBERS","DELETE_GROUP","FIND_GROUPS","FIND_GROUPS_FOR_ADMIN","FIND_TARGET_GROUPS","GET_GROUP_ADMINS","GET_GROUP_BY_ID","GET_GROUP_OPERATIONS","GET_GROUP_RELATIONS","GET_GROUPS","REMOVE_GROUP_ADMINS","REMOVE_GROUP_MEMBERS","UPDATE_GROUP","ADD_KYC","APPROVE_KYC","REJECT_KYC","SEARCH_KYC","SEARCH_PENDING_KYC","addResellerRole","updateResellerRole","deleteResellerRole","createContract","updateContract","createContractPriceEntries","updateContractPriceEntries","updateProductEntryStatus","deleteContractPriceEntries","createPasswordPolicy","updatePasswordPolicy","changeParent","TRANSFER","TOPUP","IMPORT_INVENTORY","biFetchTransaction","deleteUsers","createResellerType","updateResellerType","deletePasswordPolicy"]) {     drop {}
  }

  if([eventName] == "IMPORT_INVENTORY"){
    prune{
        whitelist_names => ["^eventName$","^timestamp$","^user.userId$","^eventType$","^channel$","^transactionNumber$","^user.resellerMSISDN$","^resultCode&","^resultMessage&","^transactionProfile&"]
    }
  }

 # if( [eventName] in ["UPDATE_PRODUCT","DELETE_PRODUCT","DELETE_CATEGORY","ADD_CATEGORY","UPDATE_CATEGORY","ADD_PRODUCT","ADD_PRODUCT_VARIANT"] and [eventType] in ["Report"]){
  #   drop {}

 # }

if(![transactionNumber]) {
    mutate {
        add_field => { "transactionNumber" => "%{ersReference}" }
    }
}

if([channel] == "USSD") {
        mutate {
           replace => { "user.userId" => "%{user.resellerId}" }
        }
}

date {
        match => ["timestamp","yyyy-MM-dd HH:mm:ss","yyyy-MM-dd'T'HH:mm:ss.SSSZ"]
        timezone => "UTC"
        target => "timestamp"
    }

 if ([rootComponent] or [channel] == "USSD"){
  ruby {
 code => "
        require 'date'
      week_n = event.get('timestamp').time.strftime '%V'
      month_n = event.get('timestamp').time.strftime '%m'
      year_n = event.get('timestamp').time.strftime '%Y'
      if(week_n == '01' && month_n == '12')
        year_n = (year_n.to_i + 1)
        week_num = year_n.to_s + 'w' + week_n.to_s
      else if (month_n == '01' && week_n.to_i > 50)
        year_n = (year_n.to_i - 1)
        week_num = year_n.to_s + 'w' + week_n.to_s
      else
        week_num = year_n.to_s + 'w' + week_n.to_s
      end
     end
      event.set('[@metadata][week_num]', week_num)
          "
   }

  prune {
   blacklist_names => ["log","tags","agent","message","path","@version","host","ecs","input","cloud"]
  }
}

else {

    if([eventName] != "IMPORT_INVENTORY"){
        prune {
             whitelist_names => ["^timestamp$","%{componentName}","transactionNumber"]
        }
    }
    ruby {
      code => "
        require 'date'
      week_n = event.get('timestamp').time.strftime '%V'
      month_n = event.get('timestamp').time.strftime '%m'
      year_n = event.get('timestamp').time.strftime '%Y'
      if(week_n == '01' && month_n == '12')
        year_n = (year_n.to_i + 1)
        week_num = year_n.to_s + 'w' + week_n.to_s
      else
        week_num = year_n + 'w' + week_n
      end
      event.set('[@metadata][week_num]', week_num)
          "
   }
 }

}
output {

     elasticsearch {
                action => "update"
                hosts => [ "localhost:9200" ]
                index => "audit_%{[@metadata][week_num]}"
                document_id => "%{transactionNumber}"
                doc_as_upsert => true
            }

  stdout {codec => rubydebug}
}
