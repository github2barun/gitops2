input {
  file {
    start_position => "beginning"
    path => ["/var/seamless/log/dealer-management-system/dealer-management-system-data.dump*"]
    sincedb_path => "/var/seamless/log/logstash/sincedb_reseller_data_lake.log"
  }
}

#Filebeat pipeline configuration
#input {
#      pipeline { address => resellerDataLakePipeline }
#}

#Filter out the logs before inserting to data lake
filter{

        json
        {
            source => "message"
        }
        if "_jsonparsefailure" not in [tags]
        {
           if ("addReseller" in [eventName] or "updateReseller" in [eventName] and [DMS])
           {
               date
               {
                         match => ["timestamp","yyyy-MM-dd HH:mm:ss"]
                         timezone => "UTC"
                         target => "timestamp"
               }
               ruby {
                           code => "
                               require 'date'
                               week_n = event.get('timestamp').time.strftime '%V'
                               month_n = event.get('timestamp').time.strftime '%m'
                               year_n = event.get('timestamp').time.strftime '%Y'
                               if(week_n == '01' && month_n == '12')
                                year_n = (year_n.to_i + 1)
                                week_num = year_n.to_s + 'w' + week_n.to_s
                               else if (month_n == '01' && week_n.to_i > 50)
                                year_n = (year_n.to_i - 1)
                                week_num = year_n.to_s + 'w' + week_n.to_s
                               else
                                week_num = year_n.to_s + 'w' + week_n.to_s
                               end
                               end
                               event.set('[@metadata][week_num]', week_num)
                               "
                         }
               split{
                        field=>"DMS"
               }
               prune
               {
                         blacklist_names => ["^log$","^tags$","^agent$","^message$","^path$","^@version$","^host$","^ecs$","^input$","^cloud$"]
               }
               ruby  {
                          code => '
                                  dmsData=event.get("[DMS]")
                                  dmsData.each { |key,value|
                                    if key=="resellerInfo"
                                        resellerInfoData=event.get("[DMS][#{key}]")
                                        resellerInfoData.each{ |keyRI,valueRI|
                                            if keyRI=="reseller"
                                                subFieldData=event.get("[DMS][resellerInfo][#{keyRI}]")
                                                subFieldData.each { |key,value|
                                                     keyField="dms.resellerInfo.#{keyRI}.#{key}"
                                                     event.set(keyField,value)
                                                }
                                            else if keyRI=="users" || keyRI=="additionalFields"
                                                 subFieldData=event.get("[DMS][resellerInfo][#{keyRI}]")
                                                 # i=0
                                                 # while i< subFieldData.length do
                                                 #    data=event.get("[DMS][resellerInfo][#{keyRI}][#{i}]")
                                                 #    data.each { |key,value|
                                                 #           keyField="dms.resellerInfo.#{keyRI}.#{i}.#{key}"
                                                 #           event.set(keyField,value)
                                                 #    }
                                                 #    i+=1
                                                 #end
                                                 keyField="dms.resellerInfo.#{keyRI}"
                                                 event.set(keyField,subFieldData)
                                            end
                                            end
                                        }
                                    else
                                        keyField="dms.#{key}"
                                        event.set(keyField,value)
                                    end
                                  }
                          '
               }
               mutate{
                      remove_field=>["DMS"]
               }
           }
           else {
                  drop {}
           }
        }
        else
        {
               ruby {
                    code => "
                        puts 'Transaction skipped due to invalid JSON format'
                        require 'date'
                        week_n = event.get('@timestamp').time.strftime '%V'
                        month_n = event.get('@timestamp').time.strftime '%m'
                        year_n = event.get('@timestamp').time.strftime '%Y'
                        if(week_n == '01' && month_n == '12')
                        year_n = (year_n.to_i + 1)
                        week_num = year_n.to_s + 'w' + week_n.to_s
                        else if (month_n == '01' && week_n.to_i > 50)
                        year_n = (year_n.to_i - 1)
                        week_num = year_n.to_s + 'w' + week_n.to_s
                        else
                        week_num = year_n + 'w' + week_n
                        end
                        end
                        event.set('[@metadata][week_num]', week_num)
                    "
               }
       }
}

output {
        if "_jsonparsefailure" in [tags]
        {
            elasticsearch {
             action => "index"
             hosts => [ "localhost:9200" ]
             #user => elastic
             #password => seamless2021
             index => "reseller_txn_parsing_failure_%{[@metadata][week_num]}"
            }
        }
        else
        {
             if ![dms.resellerInfo.reseller.resellerId]
             {
                   elasticsearch {
                        action => "index"
                        hosts => [ "localhost:9200" ]
                        #user => elastic
                        #password => seamless2021
                        index => "reseller_txn_parsing_failure_%{[@metadata][week_num]}"
                   }
             }
             else
             {
                   elasticsearch {
                        action => "update"
                        hosts => [ "localhost:9200" ]
                        #user => elastic
                        #password => seamless2021
                        index => "reseller_data_lake"
                        document_id => "%{dms.resellerInfo.reseller.resellerId}"
                        doc_as_upsert => true
                   }
             }
        }
        stdout { codec => rubydebug}
}
